문자열 source 매개변수
1. 새로운 문자열 dest 만듬
2. source가 빈 문자열인 경우 새로운 문자열 dest 리턴
3. 아니면 source에 있는 알파벳을 종류별로 뽑고 dest 뒤에 알파벳 순서대로 붙임, source가 빌 때 까지 반복


124-456 하이픈을 기준으로 전화번호 생성
희망 전화번호는 123-4xx와 같은 형식, 이때 x는 0~9중 아무거나 괜찮다는 의미
이때 존재하는 전화번호 또한 x를 사용하고 이는 12x-4x6이라면 123-456, 125-486등의 전화번호가 사용중이라는 뜻
하이픈을 제거한 숫자가 작은 순서대로 1차원 문자열 배열에 담아 return


토너먼트
탈락하지 않은 선수들의 번호를 작은 것 부터 a[1] ~ a[2t]
a[1]은 a[2]와 승부를 겨루고 a[2t-1]은 a[2t]와 승부 무승부는 없다
1명만 남을 때 까지 진행하며 선수는 '프로'와 '아마추어'로 구분
스페셜 매치는 프로가 속해있는 매치로, 스페셜 매치를 늘리기 위해 적절히 아마추어를 프로로 바꿔야한다(1회, 교환 가능)


10억개의 숫자중 가장 작은 100만개의 숫자를 추출하는데 효과적인 알고리즘, 메모리, 소요 시간

힙(Heap) 사용 * 이게 답인듯 난 퀵정렬 말함
알고리즘: 최소 힙(Min Heap) 또는 최대 힙(Max Heap)을 사용합니다. 10억 개의 숫자 중 가장 작은 100만 개를 찾기 위해서는 최대 힙을 사용하는 것이 효과적입니다. 이 알고리즘의 핵심은 최대 힙에 100만 개의 숫자만 유지하면서 나머지 숫자들을 순차적으로 비교하고, 힙의 크기가 100만 개를 넘지 않도록 조정하는 것입니다.

메모리: 100만 개의 숫자만 메모리에 저장하므로, 메모리 사용량은 상대적으로 적습니다.
시간 복잡도: 각 숫자를 힙에 삽입하는 데 O(logN)의 시간이 소요되며, 전체적으로 O(NlogM)의 시간이 소요됩니다. 여기서 N은 전체 숫자의 수(10억), M은 힙의 크기(100만)입니다.


uuid, 사용자 id, itemId, createAt 의 데이터베이스를 분산하는 방법과 유의사항

샤딩(Sharding): 데이터를 여러 데이터베이스에 수평으로 분할합니다. 각 샤드는 데이터베이스의 부분 집합을 저장하며, 각각 독립적으로 작동할 수 있습니다. 예를 들어, 사용자 ID나 itemId를 기준으로 샤딩할 수 있습니다.

파티셔닝(Partitioning): 데이터를 논리적으로 분할하지만, 물리적으로는 같은 데이터베이스 시스템 내에 위치시킵니다. 파티셔닝은 더 쉽게 관리할 수 있으나, 샤딩에 비해 확장성이 제한될 수 있습니다.

복제(Replication): 데이터의 복사본을 여러 서버에 분산하여 저장합니다. 이는 주로 가용성과 읽기 성능을 향상시키기 위해 사용됩니다. 쓰기 작업은 주 서버에만 수행되고, 읽기 작업은 복제된 서버에서 수행될 수 있습니다.

유의사항
일관성(Consistency): 데이터가 여러 곳에 분산되어 있을 때, 모든 위치에서 데이터의 일관성을 유지하는 것이 중요합니다. 이를 위해 일관성 유지 메커니즘을 적절히 선택하고 구현해야 합니다.

복잡성(Complexity): 데이터베이스를 분산하면 시스템의 복잡성이 증가합니다. 따라서, 관리, 모니터링, 백업 등의 작업이 더 어려워질 수 있으므로, 이에 대비한 추가적인 계획과 자원이 필요합니다.

네트워크 지연(Network Latency): 데이터가 여러 위치에 분산되어 있을 경우, 네트워크 지연이 쿼리 성능에 영향을 줄 수 있습니다. 따라서, 데이터 액세스 패턴을 분석하여 적절한 분산 전략을 수립해야 합니다.

데이터 무결성(Data Integrity): 외래 키 제약 조건과 같은 데이터 무결성을 유지하는 것이 더 어려워질 수 있습니다. 데이터가 여러 곳에 분산되어 있기 때문에, 트랜잭션이 여러 샤드에 걸쳐 있을 때 데이터 무결성을 유지하기 위한 추가적인 메커니즘이 필요합니다.

복구와 재해 복구(Recovery and Disaster Recovery): 데이터베이스가 분산되어 있을 때, 각 샤드나 파티션의 백업과 복구 계획을 세워야 합니다. 재해 발생 시 데이터를 복구할 수 있는 전략이 중요합니다.

분산 데이터베이스 설계와 구현은 복잡할 수 있으나, 대규모 데이터를 효율적으로 처리하고 관리하는 데 필수적입니다. 적절한 계획과 실행으로, 시스템의 확장성, 성능, 가용성을 크게 향상시킬 수 있습니다.